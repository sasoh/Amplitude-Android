group = ARTIFACT_GROUP
version = ARTIFACT_VERSION

buildscript {
    repositories {
        google()
        jcenter()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:3.5.2'
        classpath 'com.github.jengelman.gradle.plugins:shadow:6.1.0'    // max shadowJar version on gradle 6.x
    }
}

apply plugin: 'com.android.library'
apply plugin: 'maven'
apply plugin: 'signing'
apply plugin: 'com.github.johnrengelman.shadow'    // required by shadowJar
// shadowJar warning: when building for android (using com.android.library):
// 1 - we cannot use -- apply plugin: 'java' --
// 2 - official shadowJar documentation does not cover this case

ext {
    artifactId = 'amplitude-android-sdk'
}

repositories {
    // The order in which you list these repositories matter.
    google()
    jcenter()
}

android {
    compileSdkVersion 28
    buildToolsVersion '28.0.3'

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    defaultConfig {
        minSdkVersion 14
        // Note: Can't target to the latest 29 now, since running Robolectric tests on 29 will
        // require Java 9 above. However, Android Studio will error out when setting up Java to 9
        // above.
        targetSdkVersion 28

        buildConfigField "String", "AMPLITUDE_VERSION", "\"${version}\""

        testInstrumentationRunner 'androidx.test.ext.junit.runners.AndroidJUnit4'

        // The following argument makes the Android Test Orchestrator run its
        // "pm clear" command after each test invocation. This command ensures
        // that the app's state is completely cleared between tests.
        testInstrumentationRunnerArguments clearPackageData: 'true'
    }

    lintOptions {
        abortOnError true
        textReport true
        warningsAsErrors false
    }

    testOptions {
        unitTests.includeAndroidResources = true
    }
}

// ======== For shadowJar 6.1.0 Build ========
// The following custom code is used specifically when building on Android (using 'com.android.library').
// It may also not work for newer versions of shadowJar.
// This method involves running a pre-build task (relocateJarPackages) in a pre-build configuration (shadowing).

// define new configuration(s)
configurations {
    shadowing // we define an additional configuration (or step), which will run before build
}

// define task to generate shadowed libs, must be defined before dependencies
// you can also test the output of this task only by cmd> 'gradle relocateJarPackages'
task relocateJarPackages (type: com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
       
    classifier = 'shadowed' // this is a suffix applied to the resulting .jar name with shadowed libraries   
    def prefix = "auki."    // prefix added to each package to be relocated
    
    // function for doing the relocation of a package with exclusions
    def relocatePackageWithExclusions = { String pkg, List<String> exclusions ->
       relocate (pkg, prefix + pkg) {
           if (exclusions != null) {
               exclusions.each { 
                   exclude it
               }
           }
       }
       // you could use something similar if you want to remove a dot:
       // relocate pkg, [prefix, pkg].join('.')
    }
    
    // function for doing the full relocation of a package
    def relocatePackage = { String pkg -> 
       relocatePackageWithExclusions(pkg, [])
    }
    
    // List of jar packages to relocate.
    // Note: when unzipping a .jar, each subfolder is a package, i.e. "/org/intellij" is "org.intellij"
    relocatePackage 'okhttp3'
    // which depends on:
        relocatePackage 'okio'
        relocatePackage 'kotlin'
        relocatePackage 'org.intellij'    // this only contains annotations
        relocatePackage 'org.jetbrains'   // this only contains annotations
    // you can exclude sub packages with: 
    /*  relocatePackageWithExclusions 'org.intellij', [
            'org/intellij/whatever/**', 
            'org/intellij/whatever2/**'] */
    
    configurations = [project.configurations.shadowing] // links this task to our configuration from above
    
    dependencies {
       // ShadowJar does not rename also "META-INF/*.kotlin_*"" files, so they can generate duplicate errors.
       // However, since the relocated jars are used only by us, they should be safe to exclude.
       // Reasons why: https://stackoverflow.com/a/73069176
       exclude '**/*.kotlin_metadata'
       exclude '**/*.kotlin_module'
       exclude '**/*.kotlin_builtins'
    }
}

// =====================================


dependencies {

    // implementation 'com.squareup.okhttp3:okhttp:4.2.2'

    // ======== For shadowJar 6.1.0 Build ========
    shadowing 'com.squareup.okhttp3:okhttp:4.2.2'          // this lib is "input" (dependency) of the shadowing step (included with all its sub-dependencies)
    implementation tasks.relocateJarPackages.outputs.files // our project will embed the output of the shadowing step
    
    testImplementation 'com.squareup.okhttp3:mockwebserver:4.2.2'
    testImplementation 'org.robolectric:robolectric:4.3.1'
    testImplementation 'org.robolectric:shadows-maps:3.4-rc2'
    testImplementation 'org.powermock:powermock-module-junit4:1.6.6'
    testImplementation 'org.powermock:powermock-module-junit4-rule:1.6.6'
    testImplementation 'org.powermock:powermock-api-mockito:1.6.6'
    testImplementation 'org.powermock:powermock-classloading-xstream:1.6.6'
    testImplementation 'com.google.android:support-v4:r6'
    testImplementation 'com.google.android.gms:play-services-ads:18.3.0'
    testImplementation 'com.google.android.gms:play-services-base:17.1.0'
    testImplementation 'org.json:json:20140107'

    testImplementation "junit:junit:4.12"

    // Core library
    testImplementation 'androidx.test:core:1.2.0'

    // AndroidJUnitRunner and JUnit Rules
    testImplementation 'androidx.test:runner:1.2.0'
    testImplementation 'androidx.test:rules:1.2.0'

    // Assertions
    testImplementation 'androidx.test.ext:junit:1.1.1'
}

File secretPropsFile = project.rootProject.file('local.properties')
if (secretPropsFile.exists()) {
    // Read local.properties file first if it exists
    Properties p = new Properties()
    new FileInputStream(secretPropsFile).withCloseable { is -> p.load(is) }
    p.each { name, value -> ext[name] = value }

}

// ======== For SDK Releases ========
uploadArchives {
    repositories.mavenDeployer {
        beforeDeployment {
            MavenDeployment deployment -> signing.signPom(deployment)
        }

        pom.groupId = ARTIFACT_GROUP
        pom.version = ARTIFACT_VERSION

        pom.project {
            name project.name
            version ARTIFACT_VERSION
            packaging POM_PACKAGING
            description POM_DESCRIPTION
            url POM_URL

            scm {
                url POM_SCM_URL
                connection POM_SCM_CONNECTION
                developerConnection POM_SCM_DEV_CONNECTION
            }

            licenses {
                license {
                    name POM_LICENCE_NAME
                    url POM_LICENCE_URL
                    distribution POM_LICENCE_DIST
                }
            }
            developers {
                developer {
                    id POM_DEVELOPER_ID
                    name POM_DEVELOPER_NAME
                    email POM_DEVELOPER_EMAIL
                    organization POM_DEVELOPER_ORG
                    organizationUrl POM_DEVELOPER_ORG_URL
                }
            }
        }

        pom.whenConfigured { pom ->
            pom.dependencies*.optional = true
        }

        repository(url: RELEASE_REPOSITORY_URL) {
            authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
        }
        snapshotRepository(url: SNAPSHOT_REPOSITORY_URL) {
            authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
        }
    }
}

task install(type: Upload, dependsOn: assemble) {
    repositories.mavenInstaller {
        configuration = configurations.archives

        pom.groupId = ARTIFACT_GROUP
        pom.version = ARTIFACT_VERSION

        pom.project {
            name project.name
            version ARTIFACT_VERSION
            packaging POM_PACKAGING
            description POM_DESCRIPTION
            url POM_URL

            scm {
                url POM_SCM_URL
                connection POM_SCM_CONNECTION
                developerConnection POM_SCM_DEV_CONNECTION
            }

            licenses {
                license {
                    name POM_LICENCE_NAME
                    url POM_LICENCE_URL
                    distribution POM_LICENCE_DIST
                }
            }
            developers {
                developer {
                    id POM_DEVELOPER_ID
                    name POM_DEVELOPER_NAME
                    email POM_DEVELOPER_EMAIL
                    organization POM_DEVELOPER_ORG
                    organizationUrl POM_DEVELOPER_ORG_URL
                }
            }
        }
    }
}

task androidJavadocs(type: Javadoc, dependsOn: ':generateReleaseBuildConfig') {
    source = android.sourceSets.main.java.srcDirs
    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
    classpath += project.files('build/generated/source/buildConfig/release')

    exclude(
            '**/R.*',
            '**/security/**',
            '**/unity/**',
            '**/api/AmplitudeLog.java',
            '**/api/Constants.java',
            '**/api/DeviceInfo.java',
            '**/api/Utils.java',
            '**/api/WorkerThread.java',
            '**/api/CursorWindowAllocationException.java'
    )
    options {
        encoding = 'UTF-8'
        docEncoding = 'UTF-8'
        charSet = 'UTF-8'
    }
    failOnError false
}

task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
    classifier = 'javadoc'
    from androidJavadocs.destinationDir
}

task androidSourcesJar(type: Jar) {
    classifier = 'sources'
    from android.sourceSets.main.java.srcDirs
}

signing {
    required { isReleaseBuild() && gradle.taskGraph.hasTask(":uploadArchives") }
    sign configurations.archives
}

artifacts {
    archives androidSourcesJar
    archives androidJavadocsJar
}

def isReleaseBuild() {
    return version.contains("SNAPSHOT") == false
}

def getRepositoryUsername() {
    return hasProperty('sonatypeUsername') ? sonatypeUsername : ""
}

def getRepositoryPassword() {
    return hasProperty('sonatypePassword') ? sonatypePassword : ""
}
